Understanding Python Virtual Environments (venv / virtualenv)

When you install Python for the first time, it comes with one global environment.
That means all the packages you install using pip (for example pip install flask) are shared by every Python project on your computer.

At first, this seems fine. But after you work on multiple projects, you’ll hit a big problem.

⸻

Why global Python becomes a problem

Imagine this situation:
	•	You have a project called Project A that uses Flask 2.0
	•	You also have another project, Project B, that was built years ago on Flask 1.1

Now one day you update Flask globally with pip install –upgrade flask.
Suddenly, Project B stops working — because its code was written for the old Flask version.

This is where virtual environments come to the rescue.

⸻

What is a virtual environment?

A virtual environment is like a mini-Python world living inside a folder.
Inside that folder, Python keeps:
	•	its own copy of the Python interpreter,
	•	its own pip, and
	•	its own folder for installed packages (site-packages).

This means every project can have its own versions of dependencies without affecting others.
It’s like giving each project its own “bubble”.

⸻

Step 1 — Installing the tool

There are two ways to create virtual environments in Python:
	1.	Built-in method: python -m venv env_name (works with Python 3.3+)
	2.	Older method using a package: virtualenv (you install it using pip)

We’ll use virtualenv here, because that’s what the instructor used.

To install it globally on your machine (just once), type:

pip install virtualenv

Here, you’re not “importing” it into Python code. You’re installing a command-line tool — just like docker, git, or npm.
So after installation, you can run the virtualenv command directly from your terminal.

⸻

Step 2 — Creating a place for your environments

You can keep all your environments in one folder, just for organization.
It’s common to call it environments (or simply envs).

mkdir environments
cd environments

This folder is only to hold all your different project environments — not the projects themselves.

⸻

Step 3 — Creating your first virtual environment

Inside the environments folder, create your first one like this:

virtualenv project1_env

Here:
	•	virtualenv → the tool you installed earlier
	•	project1_env → the name of your environment folder

This command creates a new folder named project1_env, which contains:
	•	a local Python interpreter
	•	a local version of pip
	•	folders like bin, lib, and include

So even though it uses your system Python to start, everything it installs later stays inside this folder.

⸻

Step 4 — Activating the environment

Now you need to activate it — which means telling your terminal:
“From now on, use the Python and pip inside this environment.”

If you’re on Mac or Linux:
source project1_env/bin/activate

If you’re on Windows PowerShell:
project1_env\Scripts\activate

Once activated, your command prompt changes and you’ll see this in brackets:
(project1_env)

That’s the visual signal that you’re now working inside your isolated Python world.

⸻

Step 5 — Confirming the isolation

Type which python — it will show a path that ends with /environments/project1_env/bin/python.
That means the Python you’re using is no longer the global one.

Now check your installed packages using pip list.
You’ll see just two: pip and setuptools.
This proves it’s clean and separate.

⸻

Step 6 — Installing packages locally

Now you can install anything you need for this project, for example:

pip install numpy psutil requests

These packages now exist only inside this environment — they won’t show up if you deactivate or create another environment.

To verify, do pip list again and see them listed.

⸻

Step 7 — Saving the package list

Once you’ve installed everything your project needs, you can save the list to a file.

pip freeze > requirements.txt

This command creates a text file called requirements.txt that contains exact versions of every installed package, like:

numpy==1.26.4
requests==2.31.0
psutil==5.9.8

This is super helpful for sharing or reproducing environments later.

⸻

Step 8 — Installing from a requirements file

If someone else (or you, on another computer) wants to rebuild the same setup, they just run:

pip install -r requirements.txt

The -r flag means “install from requirements file.”
It installs each package exactly as listed.

⸻

Step 9 — Deactivating the environment

When you’re done working, you can leave the environment using:

deactivate

The prompt returns to normal — you’re back in your global Python.
Now which python will again point to your global interpreter.

⸻

Step 10 — Deleting an environment

If you don’t need that environment anymore, simply delete its folder.

rm -rf project1_env

That’s it — the environment is gone.
Since all project code lives elsewhere, deleting this won’t affect your actual work.

⸻

Step 11 — Where should environments live?

You might have noticed a small confusion earlier.
There are two common approaches, and both are fine — just choose one style and stay consistent:
	1.	Central folder style — you keep all environments in one place (like /environments/).
	•	Cleaner if you work on many projects.
	•	Keeps your main project folder lightweight.
	2.	Project-local style — you create the virtual environment inside the project folder (e.g., my_project/venv/).
	•	Easier when sharing with others — you can just say “activate the venv in this folder.”
	•	Preferred by most frameworks today (like Django).

If you’re working solo or on personal projects, style (2) is more convenient.

So, a project might look like this:

my_project/
├── venv/ ← your virtual environment folder
├── app.py
├── requirements.txt
└── README.md

⸻

Step 12 — Creating an environment with a specific Python version

You can also choose which Python version the environment should use.

Example:
virtualenv -p /usr/bin/python3.10 myenv

Here, -p means “use this specific Python interpreter.”
Now when you activate and run python –version, it will show Python 3.10.

If you installed Python 2.6 or another version somewhere else, you could use:
virtualenv -p /usr/bin/python2.6 old_env

⸻

Step 13 — Recreating an environment from requirements.txt

If you get a new computer, or want to rebuild the environment later:
	1.	Create a new virtualenv as usual.
	2.	Activate it.
	3.	Run pip install -r requirements.txt

Now you’ve restored everything exactly as it was before.

⸻

Step 14 — Things not to do

One common mistake beginners make:
They start writing their project code inside the environment folder.

Never do that.
The virtual environment exists only to store dependencies.
Your project code should live outside of it, so that even if you delete the environment, your code remains safe.

⸻

Step 15 — Summary (for quick recall)

Here’s a quick mental checklist — no table needed this time:
	•	Install virtualenv → pip install virtualenv
	•	Create environment → virtualenv myenv
	•	Activate → source myenv/bin/activate (Linux/mac) or myenv\Scripts\activate (Windows)
	•	Install packages → pip install flask numpy …
	•	Save list → pip freeze > requirements.txt
	•	Reinstall later → pip install -r requirements.txt
	•	Deactivate → deactivate
	•	Delete → rm -rf myenv
	•	Use specific Python version → virtualenv -p /usr/bin/python3.10 myenv

⸻

Step 16 — Why this matters in real life

Virtual environments are a small concept but make a huge difference.
They keep your projects stable, reproducible, and safe from dependency conflicts.
In real workplaces or production servers, every project you run — even tiny scripts — will almost always live inside a virtual environment.

You can think of it as your project’s personal sandbox:
no outside interference, no accidental upgrades, and full control over your dependencies.